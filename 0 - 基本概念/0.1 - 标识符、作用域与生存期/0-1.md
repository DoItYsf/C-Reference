# 标识符
标识符是数字、下划线、小写及大写拉丁字母和以 \u 及 \U 转义记号指定的 Unicode 字符 的任意长度序列。合法的标识符必须以非数字字符（拉丁字母、下划线或 Unicode 非数字字符）开始。标识符大小写有别（小写和大写字母不同）。
c99开始，可以用以下方式定义变量：
```c
char *\U0001f431 = "cat"; // 受支持
char *🐱 = "cat"; // 实现定义（ Clang 可用，但版本 10 前的 GCC 不可）
```
# 作用域
C程序中出现的每个标识符都仅在一些可能不连续的部分可见，这些部分被称为*作用域*。

在作用域内，标识符仅在不同命名空间中，可以指代不同的实体。

C语言拥有四种作用域：
- 块作用域
- 文件作用域
- 函数作用域
- 函数原型作用域

## 嵌套作用域
如果相同标识符所命名的两个不同个实体在同一时刻都在作用域中，且他们属于统一命名空间，则作用域被嵌套，而内层作用域中的声明隐藏外层作用域中的声明：
```c
/*************************************************************************
	> File Name: 0-1-1.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 17时56分13秒
 ************************************************************************/

#include<stdio.h>
int a; //名称为 a 的文件作用域始于此

void f(void)
{
	int a = 1; //名称 a 的块作用域开始于此处：隐藏文件作用域的a
	{
		int a = 2;		   //内层 a 的作用域开始于此处，隐藏外层 a
		printf("%d\n", a); //
	}
	printf("%d\n", a); //外层 a 的作用域开始于此处
}

void g(int a); //名称 a 拥有函数原型作用域；隐藏文件作用域 a

int main()
{
	f();
	return 0;
}

```
编译指令：
```shell
gcc 0-1-1.c -o 0-1-1
```
执行结果：
```shell
> ./0-1-1
2
1
```
## 块作用域
任何在复合语句，包含函数体或出现于 if、switch、for、while 或 do-while 语句中的任何表达式、声明或语句，或在函数定义内的参数列表中声明的标识符的作用域，在声明点开始，在声明于其中的块或语句的结尾结束。
```c
/*************************************************************************
	> File Name: 0-1-2.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 18时01分01秒
 ************************************************************************/

#include<stdio.h>
void f(int n){
	++n;
	for(int n = 0;n<10;n++){
		printf("%d", n);
	}
	printf("\n%d\n", n);
}

int main(){
	f(2);
	return 0;
}
```
编译指令：
```
gcc 0-1-2.c -o 0-1-2
```
执行结果：
```
> ./0-1-2
0123456789
3
```
如果作用域出现错误：
```c
/*************************************************************************
	> File Name: 0-1-3.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 18时01分01秒
 ************************************************************************/

#include<stdio.h>
void f(int n){
	++n;
    int n = 2;//错误：不能在同一作用域重声明标识符
}
int a = n;//错误：n 不在作用域内

int main(){
	f(2);
	return 0;
}
```
编译指令：
```shell
gcc 0-1-3.c -o 0-1-3
```
报错：
```
0-1-3.c: In function ‘f’:
0-1-3.c:11:9: error: ‘n’ redeclared as different kind of symbol
   11 |     int n = 2;
      |         ^
0-1-3.c:9:12: note: previous definition of ‘n’ was here
    9 | void f(int n){
      |        ~~~~^
0-1-3.c: At top level:
0-1-3.c:13:9: error: ‘n’ undeclared here (not in a function)
   13 | int a = n;
      |         ^
```
## 文件作用域
在任何块或参数列表外声明的任何标识符的作用域，在声明点开始，翻译单元尾结束。

文件作用域的标识符默认拥有外部链接和静态存储期。
```c
/*************************************************************************
	> File Name: 0-1-4.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 18时14分37秒
 ************************************************************************/

#include<stdio.h>
int a = 1; //文件作用域
int main(){
    printf("%d\n",a);
    return 0;
}
```
编译指令：
```
gcc 0-1-4.c -o 0-1-4
```
执行结果：
```
> ./0-1-4
1
```
## 函数作用域
声明于函数内部的标号（且只有标号），在该函数中的所有位置（所有嵌套块中，其自身声明前后）都在作用域内。注意：任何语句前的冒号字符前的标识符，若不用于其他用途，则隐式声明一个标号。
```c
/*************************************************************************
	> File Name: 0-1-5.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 18时19分30秒
 ************************************************************************/

#include<stdio.h>
void f()
{
	goto label; // label 在作用域中，尽管之后才声明
	label:;
}
void g()
{
	goto label; // 错误： g() 中 label 不在作用域中
}
int main(){
	f();
	return 0;
}
```
编译指令：
```
gcc 0-1-5.c -o 0-1-5
```
报错：
```
0-1-5.c: In function ‘g’:
0-1-5.c:16:2: error: label ‘label’ used but not defined
   16 |  goto label; // 错误： g() 中 label 不在作用域中
      |  ^~~~
```
## 函数原型作用域
非函数定义的函数声明的参数列表中引入的名称的作用域，在函数声明器的结尾结束。
```c
int f(int n,
      int a[n]); // n 在作用域中并指代第一参数
```
- 注意：若声明中有多个或嵌套声明器，则作用域在最近的外围函数声明器的结尾结束。
```c
void f ( // 函数名 'f' 在文件作用域
 long double f,            // 标识符 'f' 现在在作用域中，隐藏文件作用域的 'f'
 char (**a)[10 * sizeof f] // 'f' 指代第一参数，它在作用域中
);
 
enum{ n = 3 };
int (*(*g)(int n))[n]; // 函数参数 'n' 的作用域在其函数声明器的结尾结束
                       // 数组声明器中，全局 n 在作用域
// （这声明指向返回 3 个 int 的数组的指针的函数的指针）
```
## 声明点
结构体、联合体及枚举标签的作用域，在声明该标签的类型指定符中的标签出现后立即开始。
```c
struct Node {
   struct Node* next; // Node 在作用域中并指代此 struct
};
```
枚举常量的作用域，在枚举项列表中其定义枚举项的出现后立即开始。
```c
/*************************************************************************
	> File Name: 0-1-6.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月22日 星期三 18时31分19秒
 ************************************************************************/

#include<stdio.h>
int main(){
	enum{x = 12};{
		printf("x: %d\n",x);
		enum{
			x = x + 1, // 新 x 在逗号前不在作用域中，初始化 x 为 13
			y = x + 1  // 新枚举项 x 现在在作用域中，初始化 y 为 14
		};
		printf("x: %d\n",x);
		printf("y: %d\n",y);
	}
	return 0;
}
```
编译指令：
```shell
gcc 0-1-6.c -o 0-1-6
```
执行结果：
```shell
> ./0-1-6
x: 12
x: 13
y: 14
```
任何其他标识符的作用域，正好在其声明器结束后和初始化器前开始，若存在初始化器：
```c
int x = 2; // 第一个 'x' 的作用域开始
{
    int x[x]; // 新声明的 x 的作用域在声明器 （ x[x] ）后开始。
              // 在声明器内，外层 'x' 仍在作用域中。
              // 这声明 2 个 int 的 VLA 数组。
}
 
unsigned char y = 32; // 外层 'y' 的作用域开始
{
    unsigned char y = y;
            // 内层 'y' 的作用域在初始化器（ = y ）前开始
            // 这不会以值 32 初始化内层 'y' ，
            // 这以其自身的不确定值初始化内层 'y'
}
 
unsigned long factorial(unsigned long n)
// 声明器结束， 'factorial' 从此点开始在作用域中
{
   return n < 2 ? 1 : n * factorial(n - 1); // 递归调用
}
```
作为特殊情况，非标识符声明的类型名的作用域，被认为正好假如在类型名内未省略标识符，则标识符会出现的位置之后开始。

# 生存期
C 中每个对象的生存期是指存在、拥有常地址、保有其最近一次存储值（除非其值不确定）（，C99以后，对于 VLA 还有保有其大小）的程序执行部分。

对于声明有自动、静态及线程存储期的对象，生存期等于其存储期（注意非 VLA 和 VLA 自动存储期的区别）。

对于拥有分配存储期的对象，其生存期始于分配函数的返回（包含从 realloc 返回），终于 realloc 或解分配函数的调用。注意因为分配的对象没有声明类型，首次访问该对象所用的左值表达式类型会成为其有效类型。

在生存期外访问对象是未定义行为。
- 当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称 *悬垂指针* （也叫 *迷途指针* ）。 某些编程语言允许未初始化的指针的存在，而这类指针即为 *野指针* 。
```c
/*************************************************************************
	> File Name: 0-1-7.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月23日 星期四 07时54分31秒
 ************************************************************************/

#include <stdio.h>
int *foo(void)
{
	int a = 17; // a拥有自动存储期
	return &a;
} // a的生存期结束
int main(void)
{
	int *p = foo();		   // p 指向生存期结束后的对象（“悬垂指针”）1
	int n = *p;			   // 未定义行为
	printf("n = %d\n", n); // n 值不确定。
	return 0;
}
```
编译指令：
```shell 
gcc 0-1-7.c -o 0-1-7
```
警告：
```shell
0-1-7.c: In function ‘foo’:
0-1-7.c:12:9: warning: function returns address of local variable [-Wreturn-local-addr]
   12 |  return &a;
      |
```
执行结果：
```
> ./0-1-7
段错误
```
## 临时生存期
*非左值表达式* 所指代的拥有数组成员的结构体和联合体对象（直接为其成员或为嵌套的结构体/联合体成员）拥有临时生存期。临时生存期始于求值指代该对象的表达式，终于下一个序列点 (C11 前)包含它的完整表达式或完整声明器结束 (C11 起)。

任何修改临时生存期对象的尝试会导致未定义行为。
```c
/*************************************************************************
	> File Name: 0-1-8.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2021年12月23日 星期四 08时18分06秒
 ************************************************************************/

#include<stdio.h>
struct T
{
	double a[4];
};
struct T f(void)
{
	return (struct T){3.15};
}
double g1(double *x)
{
	return *x;
}
void g2(double *x)
{
	*x = 1.0;
}
int main(void)
{
	double d = g1(f().a); // C99 ： UB 访问生存期结束于 g1 开序列点的 a[0]
						  // C11 ： OK ， d 为 3.15
	printf("d = %.2f\n", d);
	g2(f().a);			  // C99 ： UB 修改生存期结束于序列点的 a[0]
						  // C11 ： UB 试图修改临时对象
}
```
编译指令：
```shell
gcc 0-1-8.c -o 0-1-8
```
执行结果：
```shell
> ./0-1-8
d = 3.15
```
