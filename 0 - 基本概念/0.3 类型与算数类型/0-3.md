# **类型与算数类型**
对象、函数和表达式拥有称为类型的属性，它确定存储于对象或表达式求值所得的二进制值的转译方式。

## **类型分类**
C类型系统由下列类型组成：
- `void` 类型
- 基本类型
    - `char` 类型
    - 有符号整数类型
        - 标准： `signed char`、`short、int`、`long`、`long long`
        - 扩展： 实现定义，如 `__int128`
    - 无符号整数类型
        - 标准： `_Bool`、`unsigned char`、`unsigned short`、`unsigned int`、`unsigned long`、`unsigned long long`
        - 扩展： 实现定义，如：`__uint128`
    - 浮点类型
        - 实浮点类型： `float`、`double`、`long double`
        - 十进制实浮点类型(C23 起)： `__Decimal32`、`__Decimal64`、`__Decimal128`
        - 复数类型： `float _Complex`、`double _Complex`、`long double _Complex`
        - 虚数类型： `float _Complex`、`double _Complex`、`long double _Complex`
- 枚举类型
- 派生类型
    - 数组类型
    - 结构体类型
    - 联合体类型
    - 函数类型
    - 指针类型
    - 原子类型(C11 起)

对于上面列出的每个类型，可以存在数种其类型的限定版本，对应 `const`、`volatile` 和 `restrict` 限定符的一、二或全部三个组合（在限定符的语义所允许处）。
### **类型组别**
- 对象类型：所有不是函数类型的类型
- 字符类型： char 、 signed char 、 unsigned char
- 整数类型： char 、有符号整数类型、无符号整数类型、枚举类型
- 实数类型：整数类型和实浮点类型
- 算术类型：整数类型和浮点类型
- 标量类型：算术类型和指针类型
- 聚合类型：数组类型和结构体类型
- 派生声明器类型：数组类型、函数类型和指针类型
## **兼容类型**
C 程序中，在不同翻译单元中涉及同一对象或函数的声明，不必拥有相同类型。它们只需要拥有相似的类型，正式而言即兼容类型。同样的规则应用到函数调用和左值访问；实参类型必须与形参类型兼容，而左值表达式类型必须与被访问对象的类型兼容。

类型 T 与 U 兼容，若
- 它们是同一类型（同名或由 typedef 引入的别名）
- 它们是兼容的无限定类型的等同 cvr 限定版本
- 它们是指针类型，并指向兼容类型
- 它们是数组类型，且
    - 其元素类型兼容，且
    - 若都拥有常量大小，则大小相同。注意：未知边界数组与任何兼容元素类型的数组兼容。 VLA 与任何兼容元素类型的数组兼容。 (C99 起)
- 它们都是结构体/联合体/枚举类型，且
    - 若一者以标签声明，则另一者必须以同一标签声明。(C99)
    - 若它们都是完整类型，则其成员必须在数量上准确对应，以兼容类型声明，并拥有匹配的名称。
    - 另外，若它们都是枚举，则对应成员亦必须拥有相同值。
    - 另外，若它们是结构体或联合体，则
        - 对应的元素必须以同一顺序声明（仅结构体）
        - 对应的位域必须有相同宽度。
- 一者为枚举类型，而另一者为该枚举的底层类型
- 它们是函数类型，且
    - 其返回类型兼容
    - 它们都使用参数列表，参数数量（包括省略号的使用）相同，而其对应参数，在应用数组到指针和函数到指针类型调整，及剥除顶层限定符后，拥有相同类型
    - 一个是旧式（无参数）定义，另一个有参数列表，参数列表不使用省略号，而每个参数（在函数参数类型调整后）都与默认参数提升后的对应旧式参数兼容
    - 一个是旧式（无参数）声明，另一个拥有参数列表，参数列表不使用省略号，而所有参数（在函数参数类型调整后）不受默认参数提升影响

类型 `char` 既不与 `signed char` 兼容，也不与 `unsigned char` 兼容。

若涉及同一对象或函数的二个声明不使用兼容类型，则程序的行为未定义。
```c
/*************************************************************************
	> File Name: 0-3-1-A.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2022年01月01日 星期六 09时18分32秒
 ************************************************************************/

#include <stdio.h>
// 翻译单元 A
struct s
{
	int i;
};						 // 与 C 的 s 兼容，但不与 B 的 s 兼容
extern struct s x = {0}; // 与 C 的 x 兼容
extern void f(void);	 // 与 B 的 f 兼容
int main()
{
	f();
	return x.i;
}
```
```c
/*************************************************************************
	> File Name: 0-3-1-B.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2022年01月01日 星期六 09时18分37秒
 ************************************************************************/

#include<stdio.h>
// 翻译单元 B
struct s
{
	float f;
};							// 与 D 的 s 兼容，但不与 A 的 s 兼容
extern struct s y = {3.14}; // 与 D 的 y 兼容
void f()
{ // 与 A 的 f 兼容
	return;
}
```
```c
/*************************************************************************
	> File Name: 0-3-1-C.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2022年01月01日 星期六 09时18分42秒
 ************************************************************************/

#include<stdio.h>
// 翻译单元 C
struct s
{
	int i;
};				   // 与 A 的 s 兼容，但不与 B 的 s 兼容
extern struct s x; // 与 A 的 x 兼容
```
```c
/*************************************************************************
	> File Name: 0-3-1-D.c
	> Author: DoItYsf
	> Mail: javathon@hotmail.com
	> Created Time: 2022年01月01日 星期六 09时18分46秒
 ************************************************************************/

#include<stdio.h>
// 翻译单元 D
struct s
{
	float f;
};				   // 与 B 的 s 兼容，但不与 A 的 s 兼容
extern struct s y; // 与 B 的 y 兼容
```
编译指令：
```shell
gcc -c 0-3-1-B.c 0-3-1-C.c 0-3-1-D.c
ar rcs lib0-3-1.a 0-3-1-B.o 0-3-1-C.o 0-3-1-D.o
gcc -c 0-3-1-A.c 
gcc -static 0-3-1-A.o lib0-3-1.a -o a
```
执行结果：
```shell
> ./a

```
- 注：因为没有调用`printf`函数，所以此程序没有输出。

## **合成类型**
合成类型能从两个兼容的类型构造；它是与两个类型兼容，并满足下列条件的类型：
- 若两个类型均为数组类型，则应用下列规则：
    - 若一个类型是常量大小数组，则合成类型为该大小的数组。
    - 否则，若一个类型是 VLA ，而尚未求值指定其大小的表达式，则行为未定义。
    - 否则，若一个类型为已指定大小的 VLA ，则合成类型为该大小的 VLA 。
    - 否则，若一个类型为未指定大小的 VLA ，则合成类型为未指定大小的 VLA 。
    - 否则，两个数组类型都有未知大小，而合成类型为未知大小的数组。合成类型的元素类型是二个元素类型的合成类型。
- 若一个类型是有参数类型列表（函数原型）的函数类型，则合成类型为有该参数类型列表的函数原型。
- 若两个类型均为有参数类型列表的函数类型，则合成类型的参数类型列表中的每个参数类型，是对应参数的合成类型。

对于拥有内部或外部链接，并在其先前声明已经可见的作用域中再次声明的标识符，若先前的声明指定了内部或外部链接，则在后一声明中的标识符类型成为合成类型。

# **算术类型**
### **布尔类型**
- `_Bool`类型，值为 1 或 0 。注意，到`_Bool`的转换与到其他整数类型的转换不同：`(_Bool)0.5`值为 1 ，`(int)0.5`值为 0 ；
### **字符类型**
- `signed char` 用作有符号字符表示的类型
- `unsigned char` 用作无符号字符表示的类型。也可用于查看对象表示（无修饰内存）。
- `char` 用于字符表示的类型，与`signed char` 和`unsigned char` 等价（具体等价于哪个是实现定义的，并且可以通过编译器命令行开关控制），但是`char` 是独立的类型，与`signed char` 和`unsigned char` 都不相同。

### **整数类型**
- `short int` （可写作 `short`，可以用关键字`signed`）
- `unsigned short int`（可写作 `unsigned short`）
- `int` （可写作 `signed int`）这是最理想的整数类型，保证至少为16位，当前大多数平台使用32位数据。
- `unsigned int` （可写作 `unsigned`），`int` 对应的无符号类型，实现模算数，适合位操作。
- `long int` （可写作 `long`）
- `unsigned long int` （可写作 `unsigned long`）
- `long long int` （可写作 `long long`）
- `unsigned long long int` （可写作 `unsigned long long`）

C标准保证
1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
注意：这允许某些极端的情况，比如：字节大小为64位，所有类型均为64位宽，而`sizeof` 对每个整数类型都返回1。
注意：整数算数的定义对于有符号和无符号数不同。（尤其是整数溢出。）
### **数据模型**
每个实现关于基础类型的大小选择统称为数据模型。
32位系统
- **LP32**或**2/4/4**（int为16位，long与指针为32位）
    - Win16 API
- **ILP32**或**4/4/4**（int、long以及指针为32位）
    - Win32 API
    - Unix 以及类 Unix 系统
64位系统
- **LLP64**或**4/4/8**（int以及long为32位，指针为64位）
    - Win64 API
- **LP64**或**4/8/8**（int为32位，long和指针为64位）
    - Unix 与类 Unix 系统（Linux、Mac OS X）

注意：从C99开始可以从`<stdint.h>`中使用准确宽度的整数。

### **实浮点类型**
C拥有3（或6：从C23起）种表示实浮点值的类型
- `float` 单精度浮点类型。
- `double` 双精度浮点类型。
- `long double` 扩展精度浮点类型。

若实现预定义宏常量 __STDC_IEC_60559_DFP__
- `_Decimal32` 表示IEEE-754 decimal32格式。
- `_Decimal64` 表示IEEE-754 decimal64格式。
- `_Decimal128` 表示IEEE-754 decimal128格式。

否则不支持这些十进制浮点类型。

浮点类型可以支持特殊值。
- 无穷大（定义于头文件 `<math.h>` ，见 [INFINITY](../../头文件/math.h/INFINITY.md)。
- 负零、-0.0。它与正零比较相等，但对于某些算术运算有意义（如：1.0/0.0 == INFINITY，但是1.0/-0.0 == -INFINITY）。
- 非数（NaN），它与任何值比较不相等（包括其自身）。有多种位模式表示NaN（[nan](../../头文件/math.h/nan.md)，[NAN](../../头文件/math.h/NAN.md)）。注意C对NaN信号不作任何留意，并安静处理所有NaN。

实浮点数可用于算数运算符 `+ - * /` 以及 `<math.h>` 库的大量数学函数，内建运算符和库函数都可能引发浮点异常，并以[math_errhandling](../../头文件/math.h/math_errno.md)

浮点表达式可以被*缩略*（见[#pragma STDC FP_CONTRACT](../../预处理器/1.5%20%23pragma/1-5.md)）

一些浮点数上的运算会受到浮点环境的影响，或修改它（最值得注意的是舍入方向）

实浮点类型与整数、复数、虚数类型间的隐式转换有定义。
附加细节、极限和浮点类型属性见[浮点类型极限]()与[math.h](../../头文件/math.h/content.md)库

---
### **复浮点类型**
